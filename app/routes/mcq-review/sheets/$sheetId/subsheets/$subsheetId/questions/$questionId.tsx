import { useOutletContext } from "@remix-run/react";
import { useActionData, useLoaderData } from "@remix-run/react";
import { useEffect, useState } from "react";
import { json } from "@remix-run/node";
import Comments from "~/components/comments";
import { GoogleSpreadsheet } from '~/utils/spreadsheet.server';
import Chance from 'chance';


const jsonTypes = ["TEMPLATE", "CONTENT"]
const inputTypes = [
    "integer",
    "float",
    "string",
    "bool",
    "custom"
] //TODO: Move to constants - common

export async function loader({ params }) {

    const { sheetId, subsheetId, questionId } = params

    const doc = new GoogleSpreadsheet(sheetId);

    await doc.useServiceAccountAuth({
        // env var values are copied from service account credentials generated by google
        // see "Authentication" section in docs for more info
        //TODO:Need to change
        client_email: "mcqbot@mcq-comments-db.iam.gserviceaccount.com",
        private_key: "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDQRXXbVaYsPHDP\nQuSpqpIVvjalNR6n/aQkupBf+IPbSDRz6ZST21ulu9kSonH6y9vWUlXc1zw+01uw\njcyeboe7yDrVE9K57rTcgw52GDNheHucj5NPaVHNaCCtD/mtvKFtZtA2N8Kd/vSZ\noC8ZKC3wLMTKffANOtuWQoEir47lxOmEtoekhhe+9ElI6e77AqtbH6bUi0YWY4La\nXYuzTSkOXolpKUb7dzZDUqGojPG3WasmhrsMP4isDm0VY3ltnNkJydwY9WGkl/yo\n5fn5v2k4wMqvgzZ2ngesy0yB4YrNQ2I2hYUfjceoSk4KjOCOR3vr4xYFPI8ZHnkD\nuXCLNrUNAgMBAAECggEAUiCB2ArPKzRuO5yiNLF5R6+pNr5ap13ig0U6N031GNxB\nKtAZ8bAXVKRddfauwXnv53SyPRJ2xENuLZHM9VCan5bWdD2L5BvYH/hiFHl4kWAE\nRnlrWm4qfrgn4nahOzxd35kiU67rRIhMBeRfjikE7GeK9lpw9ZaXDoqNB5N44uts\nFz4EuHypScqr0c3XnoIi9aS7FtzoFIQjykH5/9cB2l3gJ+yYrWDGqOYT5SAb8iXG\n0gQ82kXrNSMVm4Rtch6VJ3iGMSPJHBqQlxc2YxKW42KB7aGmtEK+tDjgh7mF1icp\noe+1zLdyVdpdKJ7I+GeYZKJ+pHFPnJTkCbmjvlNctQKBgQDprnvBXEBMiZTuVSQB\nyG9/xH/baqU55O7NL/dCmM4XdVCmaSVZLk9DbJv2LFWozZA7n13JsNbTyzbG8wFL\n+4XvYzM/cdBxmxWdGLtc27ZcjxjrzD5pOtKdwRH/KBlhsoCgNaAIELsr8jtAbwPf\n86uAm/1P0fsHUj+Lh6m5uZUnOwKBgQDkKbI7I1biQVRS6e4SPg7uSttDRSCxCMUX\n8t+671DwjsjRLmM8+uW3hmYHA64YqKDNOwgvX4/XHN6inJpf3JQSacxvNSgQwfYv\n4RSUAEIbtcvqVnMb2SV/vnUr3NFJzq7UQlySH6kP5TRMq0vOrQxyOJmOEE7km1Q/\nc07FWe0gVwKBgEYjyCOOpAIVHa23wnoChm0MNvBN/0/0RjUyW34SzXE/FjkMwFgX\nTVVIiTuHrSJgqRUsTYNXX/PsQAHROKds1JO46830RIOE8CTaIorJq9/2V52XDXia\nXlNZeyRiDdRENtVfoywokXWsXFqHt9sFkYmlyI+n0DgvWMFxs+D6Mim3AoGAfuNN\ncqQZqqSIX8AnHVAT/6PzwrqMDsiAy+vPTufOzKmrtuGkYQJrhKAi153NUXteSiSd\nTbNIjGpKyoZrOAq08nSSM/qM+JzV7BSx3Ak0urJk4EMJqyAdQajLAwTAA9sE0ZjC\nYKVo4SUn68eL1jnY5SDjDOW26l4UAWGAGjMDs+sCgYEA6U/CfBhaKmb8msq8egsn\n61xmjpo0DvNbNDGNXBnyMARvnnPcSZB3RRvjELrXCnIRF5jnjaKtKUnWoA9hW4Qg\nAA3djGf+ArG3DoWWZqOyo9aHuM3OpFJWkXEwjBT4vshbsnEebWCZXnGRlA269v+M\niP/M74zvpY2riB2uch/pqLE=\n-----END PRIVATE KEY-----\n".replace(/\\n/gm, '\n')
    });

    await doc.loadInfo();

    const commentsSheet = doc.sheetsById[subsheetId]

    const commentRows = await commentsSheet.getRows();

    const commentRowsData = commentRows.map(eachObj => {
        const commentsObj = {}
        const headerValues = eachObj["_sheet"].headerValues
        headerValues.forEach(eachHeaderValue => {
            commentsObj[eachHeaderValue] = eachObj[eachHeaderValue]
        })
        return commentsObj
    })

    return ({ sheetId, subsheetId, questionKey: questionId, comments: commentRowsData })
}

class CommentObj {
    constructor(props) {
        this.commentId = props.commentId;
        this.questionId = props.questionId;
        this.issue = props.issue;
        this.reportedTo = props.reportedTo;
        this.status = props.status;
    }
}

export const action: ActionFunction = async ({
    request, params
}) => {

    const { sheetId, subsheetId, questionId } = params
    const chanceInstance = new Chance()

    const formData = await request.formData();

    const action = await formData.get("_action");

    const createAuth = async (doc) => {
        await doc.useServiceAccountAuth({
            // env var values are copied from service account credentials generated by google
            // see "Authentication" section in docs for more info
            //TODO:Need to change
            client_email: "mcqbot@mcq-comments-db.iam.gserviceaccount.com",
            private_key: "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDQRXXbVaYsPHDP\nQuSpqpIVvjalNR6n/aQkupBf+IPbSDRz6ZST21ulu9kSonH6y9vWUlXc1zw+01uw\njcyeboe7yDrVE9K57rTcgw52GDNheHucj5NPaVHNaCCtD/mtvKFtZtA2N8Kd/vSZ\noC8ZKC3wLMTKffANOtuWQoEir47lxOmEtoekhhe+9ElI6e77AqtbH6bUi0YWY4La\nXYuzTSkOXolpKUb7dzZDUqGojPG3WasmhrsMP4isDm0VY3ltnNkJydwY9WGkl/yo\n5fn5v2k4wMqvgzZ2ngesy0yB4YrNQ2I2hYUfjceoSk4KjOCOR3vr4xYFPI8ZHnkD\nuXCLNrUNAgMBAAECggEAUiCB2ArPKzRuO5yiNLF5R6+pNr5ap13ig0U6N031GNxB\nKtAZ8bAXVKRddfauwXnv53SyPRJ2xENuLZHM9VCan5bWdD2L5BvYH/hiFHl4kWAE\nRnlrWm4qfrgn4nahOzxd35kiU67rRIhMBeRfjikE7GeK9lpw9ZaXDoqNB5N44uts\nFz4EuHypScqr0c3XnoIi9aS7FtzoFIQjykH5/9cB2l3gJ+yYrWDGqOYT5SAb8iXG\n0gQ82kXrNSMVm4Rtch6VJ3iGMSPJHBqQlxc2YxKW42KB7aGmtEK+tDjgh7mF1icp\noe+1zLdyVdpdKJ7I+GeYZKJ+pHFPnJTkCbmjvlNctQKBgQDprnvBXEBMiZTuVSQB\nyG9/xH/baqU55O7NL/dCmM4XdVCmaSVZLk9DbJv2LFWozZA7n13JsNbTyzbG8wFL\n+4XvYzM/cdBxmxWdGLtc27ZcjxjrzD5pOtKdwRH/KBlhsoCgNaAIELsr8jtAbwPf\n86uAm/1P0fsHUj+Lh6m5uZUnOwKBgQDkKbI7I1biQVRS6e4SPg7uSttDRSCxCMUX\n8t+671DwjsjRLmM8+uW3hmYHA64YqKDNOwgvX4/XHN6inJpf3JQSacxvNSgQwfYv\n4RSUAEIbtcvqVnMb2SV/vnUr3NFJzq7UQlySH6kP5TRMq0vOrQxyOJmOEE7km1Q/\nc07FWe0gVwKBgEYjyCOOpAIVHa23wnoChm0MNvBN/0/0RjUyW34SzXE/FjkMwFgX\nTVVIiTuHrSJgqRUsTYNXX/PsQAHROKds1JO46830RIOE8CTaIorJq9/2V52XDXia\nXlNZeyRiDdRENtVfoywokXWsXFqHt9sFkYmlyI+n0DgvWMFxs+D6Mim3AoGAfuNN\ncqQZqqSIX8AnHVAT/6PzwrqMDsiAy+vPTufOzKmrtuGkYQJrhKAi153NUXteSiSd\nTbNIjGpKyoZrOAq08nSSM/qM+JzV7BSx3Ak0urJk4EMJqyAdQajLAwTAA9sE0ZjC\nYKVo4SUn68eL1jnY5SDjDOW26l4UAWGAGjMDs+sCgYEA6U/CfBhaKmb8msq8egsn\n61xmjpo0DvNbNDGNXBnyMARvnnPcSZB3RRvjELrXCnIRF5jnjaKtKUnWoA9hW4Qg\nAA3djGf+ArG3DoWWZqOyo9aHuM3OpFJWkXEwjBT4vshbsnEebWCZXnGRlA269v+M\niP/M74zvpY2riB2uch/pqLE=\n-----END PRIVATE KEY-----\n".replace(/\\n/gm, '\n')
        });
    }

    const createAndReturnDoc = (sheetId) => {
        const doc = new GoogleSpreadsheet(sheetId);
        return doc
    }

    const loadDoc = async (doc) => {
        await doc.loadInfo();
    }

    const doc = await createAndReturnDoc(sheetId)
    await createAuth(doc)
    await loadDoc(doc)

    const sheet = doc.sheetsById[subsheetId]

    await sheet.loadCells();

    const rows = await sheet.getRows()


    const createCommentTemplate = (commentId, questionId, issue, reportedTo, status) => {
        const commentObj = new CommentObj({ commentId, questionId, issue, reportedTo, status })
        return commentObj
    }

    const getComments = async () => {
        const commentRows = await sheet.getRows();

        const commentRowsData = commentRows.map(eachObj => {
            const commentsObj = {}
            const headerValues = eachObj["_sheet"].headerValues
            headerValues.forEach(eachHeaderValue => {
                commentsObj[eachHeaderValue] = eachObj[eachHeaderValue]
            })
            return commentsObj
        })
        return commentRowsData
    }


    const getRowIndexByCommentId = async (commentId) => {
        const rows = await sheet.getRows();

        const requiredRowIndex = rows.findIndex(eachRowObj => eachRowObj.commentId === commentId)

        return requiredRowIndex + 1
    }


    if (action === "add") {
        const issue = formData.get("comment")
        const commentId = chanceInstance.guid({ version: 4 })
        const commentObj = createCommentTemplate(commentId, questionId, issue, "", "")

        await sheet.addRow(commentObj);
    }

    if (action === "edit") {
        const issue = formData.get("comment")
        const commentId = formData.get("commentId")

        const rowIndex = await getRowIndexByCommentId(commentId)
        const columnIndex = 2

        let cell = sheet.getCell(rowIndex, columnIndex)
        cell.value = issue

        await sheet.saveUpdatedCells();

    }

    if (action === "delete") {
        const commentId = formData.get("commentId")

        const rowIndex = await getRowIndexByCommentId(commentId)

        await rows[rowIndex - 1].delete()

    }

    if (action === "resolve") {
        const commentId = formData.get("commentId")

        await sheet.loadCells();

        const rowIndex = getRowIndexByCommentId(commentId)
        const columnIndex = 4


        let cell = sheet.getCell(rowIndex, columnIndex)
        cell.value = "done"

        await sheet.saveUpdatedCells();


    }

    console.log(await getComments(), 'comments')

    return ({ newComments: await getComments() })

}

export default function QuestionId() {
    const [templateJson, contentJson] = useOutletContext();
    const loaderData = useLoaderData();
    const [chanceInstance, setChanceInstance] = useState()

    useEffect(() => {
        const chance = new Chance()
        setChanceInstance(chance)
    }, [])


    const getJsonTypeToRender = () => {
        if (templateJson && templateJson.length > 0) {
            return jsonTypes[0]
        }
        else if (contentJson && contentJson.length > 0) {
            return jsonTypes[1] //TODO: change array to object
        }
    }

    const getCommentsByQuestionId = () => {
        return loaderData?.comments.filter(eachComment => eachComment.questionId === loaderData?.questionKey)
    }

    const getActiveQuestion = () => {
        if (getJsonTypeToRender() === jsonTypes[0]) {
            return templateJson.find(eachTemplate => eachTemplate.templateId === loaderData?.questionKey)
        }
        else {
            return contentJson.find(eachContentQuestion => eachContentQuestion.question_key === loaderData?.questionKey)
        }
    }

    const renderInput = (input) => {
        const { inputName, inputType } = input
        switch (inputType) {
            case inputTypes[0]:
                return (
                    <div>
                        <p><span>Input Name:</span>{inputName}</p>
                        <p><span>Input Type:</span>{inputType}</p>
                        <p><span>Min:</span>{input.min}</p>
                        <p><span>Max:</span>{input.max}</p>
                    </div>
                )
            case inputTypes[1]:
                return (
                    <div>
                        <p><span>Input Name:</span>{inputName}</p>
                        <p><span>Input Type:</span>{inputType}</p>
                        <p><span>Min:</span>{input.min}</p>
                        <p><span>Max:</span>{input.max}</p>
                        <p><span>Decimals:</span>{input.decimals}</p>
                    </div>
                )
            case inputTypes[2]:
                return (
                    <div>
                        <p><span>Input Name:</span>{inputName}</p>
                        <p><span>Input Type:</span>{inputType}</p>
                        <p><span>Context Type:</span>{input.contextType}</p>
                        {/* <p><span>Length:</span>{input.length}</p> */}
                    </div>
                )
            case inputTypes[3]:
                return (
                    <div>
                        <p><span>Input Name:</span>{inputName}</p>
                        <p><span>Input Type:</span>{inputType}</p>
                    </div>
                )
            case inputTypes[4]:
                return (
                    <div>
                        <p><span>Input Name:</span>{inputName}</p>
                        <p><span>Input Type:</span>{inputType}</p>
                        <p><span>Custom List:</span>{input.customList}</p>
                    </div>
                )
            default:
                return null
        }

    }

    const renderTemplateQuestion = (activeQuestion) => {
        const { templateTypes, questionText, code, templateId, cOptions, wOptions, inputs, inputVariables } = activeQuestion

        return (
            <div>
                <div><span>QuestionText:</span>{questionText}</div>
                <div><span>Template Id:</span>{templateId}</div>
                <div><span>Code:</span> <div>{code}</div></div>
                <div><span>Inputs:</span><div>{inputs.map(eachInput => renderInput(eachInput))}</div></div>
                <div><span>Input Variables:</span> {inputVariables}</div>
                <div><span>Correct Options:</span> {cOptions.join(", ")}</div>
                <div><span>Wrong Options:</span> {wOptions.join(", ")}</div>
                <div><span>Template Types:</span>{templateTypes.join(", ")}</div>
            </div>
        )
    }

    const renderCodeAnalysisQuestion = (activeQuestion) => {
        const { question_key, question_text, tag_names, input_output, code_metadata } = activeQuestion

        return (
            <div>
                <div><span>Question Key:</span>{question_key}</div>
                <div><span>Question Text:</span>{question_text}</div>
                <div><span>Tag Names:</span>{tag_names.join(", ")}</div>
                <div><span>Code:</span> {code_metadata.map(eachCode => <div>{eachCode.code_data}</div>)}</div>
                {input_output.map(eachInput => {
                    return (<>
                        <div><span>Correct Options:</span> {eachInput.output.join(", ")}</div>
                        <div><span>Wrong Options:</span> {eachInput.wrong_answers.join(", ")}</div>
                    </>)
                })}
            </div>)

    }

    const renderMultipleChoiceQuestion = (activeQuestion) => {
        const { question_key, question, options } = activeQuestion
        const { content, tag_names } = question

        const correctOptions = options.filter(eachOption => eachOption.is_correct)
        const wrongOptions = options.filter(eachOption => !eachOption.is_correct)

        return (
            <div>
                <div><span>Question Key:</span>{question_key}</div>
                <div><span>Question Text:</span>{content}</div>
                <div><span>Tag Names:</span>{tag_names.join(", ")}</div>
                <div><span>Correct Options:</span> {correctOptions.join(", ")}</div>
                <div><span>Wrong Options:</span> {wrongOptions.join(", ")}</div>
            </div>)
    }

    const renderContentQuestion = (activeQuestion) => {
        const { question_type } = activeQuestion

        if (question_type.includes("CODE")) {
            return renderCodeAnalysisQuestion(activeQuestion)
        }

        else {
            return renderMultipleChoiceQuestion(activeQuestion)
        }

    }

    const renderActiveContentQuestion = () => {
        const activeQuestion = getActiveQuestion()

        return renderContentQuestion(activeQuestion)

    }

    const renderActiveTemplateQuestion = () => {
        const activeQuestion = getActiveQuestion()

        return renderTemplateQuestion(activeQuestion)
    }


    const renderActiveQuestion = () => {
        if (getJsonTypeToRender() === jsonTypes[0]) {
            return renderActiveTemplateQuestion()
        }
        else if (getJsonTypeToRender() === jsonTypes[1]) {
            return renderActiveContentQuestion()
        }
    }

    //TODO: need to remove key
    //Issue: HTML is not rendering, Route is reloading multiple times

    return <>{renderActiveQuestion()}<Comments key={chanceInstance ? chanceInstance.guid({ version: 4 }) : ""} comments={getCommentsByQuestionId()} /></>
}
